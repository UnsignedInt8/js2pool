// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/c17b1b78b886e84afe27e1b65fe5bf901da5bbe7/bignum/index.d.ts
declare module 'bignum' {
    // Type definitions for Bignum
    // Project: https://github.com/justmoon/node-Bignum
    // Definitions by: Pat Smuk <https://github.com/Patman64>
    // Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

    /// <reference types="node" />

    export = Bignum;

    class Bignum {
        /** Create a new Bignum from n. */
        constructor(n: number | Bignum);

        /** Create a new Bignum from n and a base. */
        constructor(n: string, base?: number);

        /**
         * Create a new Bignum from a Buffer.
         * 
         * The default options are: {endian: 'big', size: 1}.
         */
        static fromBuffer(buffer: Buffer, options?: Bignum.BufferOptions): Bignum;

        /**
         * Generate a probable prime of length bits.
         * 
         * If safe is true, it will be a "safe" prime of the form p=2p'+1 where p' is also prime.
         */
        static prime(bits: number, safe?: boolean): Bignum;

        /** Return true if num is identified as a Bignum instance. Otherwise, return false. */
        static isBignum(num: any): boolean;

        /** Print out the Bignum instance in the requested base as a string. Default: base 10 */
        toString(base?: number): string;

        /**
         * Turn a Bignum into a Number.
         * 
         * If the Bignum is too big you'll lose precision or you'll get ±Infinity.
         */
        toNumber(): number;

        /**
        * Return a new Buffer with the data from the Bignum.
        * 
        * The default options are: {endian: 'big', size: 1}.
        */
        toBuffer(options?: Bignum.BufferOptions): Buffer;

        /** Return a new Bignum containing the instance value plus n. */
        add(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum containing the instance value minus n. */
        sub(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum containing the instance value multiplied by n. */
        mul(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum containing the instance value integrally divided by n. */
        div(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum with the absolute value of the instance. */
        abs(): Bignum;

        /** Return a new Bignum with the negative of the instance value. */
        neg(): Bignum;

        /**
         * Compare the instance value to n.
         * 
         * Return a positive integer if > n, a negative integer if < n, and 0 if == n.
         */
        cmp(n: Bignum.BignumCompatible): number;

        /** Return a boolean: whether the instance value is greater than n (> n). */
        gt(n: Bignum.BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is greater than or equal to n (>= n). */
        ge(n: Bignum.BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is equal to n (== n). */
        eq(n: Bignum.BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is less than n (< n). */
        lt(n: Bignum.BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is less than or equal to n (<= n). */
        le(n: Bignum.BignumCompatible): boolean;

        /** Return a new Bignum with the instance value bitwise AND (&)-ed with n. */
        and(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value bitwise inclusive-OR (|)-ed with n. */
        or(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value bitwise exclusive-OR (^)-ed with n. */
        xor(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value modulo n. */
        mod(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value raised to the nth power. */
        pow(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value raised to the nth power modulo m. */
        powm(n: Bignum.BignumCompatible, m: Bignum.BignumCompatible): Bignum;

        /** Compute the multiplicative inverse modulo m. */
        invertm(m: Bignum.BignumCompatible): Bignum;

        /**
         * If upperBound is supplied, return a random Bignum between the instance value and upperBound - 1, inclusive.
         * Otherwise, return a random Bignum between 0 and the instance value - 1, inclusive.
         */
        rand(upperBound?: Bignum.BignumCompatible): Bignum;

        /** 
         * Return whether the Bignum is:
         *  - certainly prime (true)
         *  - probably prime ('maybe')
         *  - certainly composite (false)
         */
        probPrime(): boolean | string;

        /** Return a new Bignum that is the 2^n multiple. Equivalent of the << operator. */
        shiftLeft(n: Bignum.BignumCompatible): Bignum;

        /** Return a new Bignum of the value integer divided by 2^n. Equivalent of the >> operator. */
        shiftRight(n: Bignum.BignumCompatible): Bignum;

        /** Return the greatest common divisor of the current Bignum with n as a new Bignum. */
        gcd(n: Bignum): Bignum;

        /**
         * Return the Jacobi symbol (or Legendre symbol if n is prime) of the current Bignum (= a) over n.
         * Note that n must be odd and >= 3. 0 <= a < n.
         * 
         * Returns -1 or 1 as an int (NOT a Bignum). Throws an error on failure.
         */
        jacobi(n: Bignum): number;

        /** Return the number of bits used to represent the current Bignum. */
        bitLength(): number;
    }

    namespace Bignum {
        /** Anything that can be converted to Bignum. */
        type BignumCompatible = Bignum | number | string;

        export interface BufferOptions {
            /** Can be either 'big' or 'little'. Also accepts 1 for big and -1 for little. Doesn't matter when size = 1. */
            endian: string | number;

            /** Number of bytes per word, or 'auto' to flip entire Buffer. */
            size: number | string;
        }

        /**
         * Turn a Bignum into a Number.
         * 
         * If the Bignum is too big you'll lose precision or you'll get ±Infinity.
         */
        export function toNumber(n: BignumCompatible): number;

        /**
         * Return a new Buffer with the data from the Bignum.
         * 
         * The default options are: {endian: 'big', size: 1}.
         */
        export function toBuffer(n: BignumCompatible, options?: BufferOptions): Buffer;

        /** Return a new Bignum containing the instance value plus n. */
        export function add(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum containing the instance value minus n. */
        export function sub(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum containing the instance value multiplied by n. */
        export function mul(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum containing the instance value integrally divided by n. */
        export function div(dividend: BignumCompatible, divisor: BignumCompatible): Bignum;

        /** Return a new Bignum with the absolute value of the instance. */
        export function abs(n: BignumCompatible): Bignum;

        /** Return a new Bignum with the negative of the instance value. */
        export function neg(n: BignumCompatible): Bignum;

        /**
         * Compare the instance value to n.
         * 
         * Return a positive integer if > n, a negative integer if < n, and 0 if == n.
         */
        export function cmp(left: BignumCompatible, right: BignumCompatible): number;

        /** Return a boolean: whether the instance value is greater than n (> n). */
        export function gt(left: BignumCompatible, right: BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is greater than or equal to n (>= n). */
        export function ge(left: BignumCompatible, right: BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is equal to n (== n). */
        export function eq(left: BignumCompatible, right: BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is less than n (< n). */
        export function lt(left: BignumCompatible, right: BignumCompatible): boolean;

        /** Return a boolean: whether the instance value is less than or equal to n (<= n). */
        export function le(left: BignumCompatible, right: BignumCompatible): boolean;

        /** Return a new Bignum with the instance value bitwise AND (&)-ed with n. */
        export function and(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value bitwise inclusive-OR (|)-ed with n. */
        export function or(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value bitwise exclusive-OR (^)-ed with n. */
        export function xor(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value modulo n. */
        export function mod(left: BignumCompatible, right: BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value raised to the nth power. */
        export function pow(base: BignumCompatible, exponent: BignumCompatible): Bignum;

        /** Return a new Bignum with the instance value raised to the nth power modulo m. */
        export function powm(base: BignumCompatible, exponent: BignumCompatible, m: BignumCompatible): Bignum;

        /** Compute the multiplicative inverse modulo m. */
        export function invertm(n: BignumCompatible, m: BignumCompatible): Bignum;

        /**
         * If upperBound is supplied, return a random Bignum between the instance value and upperBound - 1, inclusive.
         * Otherwise, return a random Bignum between 0 and the instance value - 1, inclusive.
         */
        export function rand(n: BignumCompatible, upperBound?: BignumCompatible): Bignum;

        /** 
         * Return whether the Bignum is:
         *  - certainly prime (true)
         *  - probably prime ('maybe')
         *  - certainly composite (false)
         */
        export function probPrime(n: BignumCompatible): boolean | string;

        /** Return a new Bignum that is the 2^bits multiple. Equivalent of the << operator. */
        export function shiftLeft(n: BignumCompatible, bits: BignumCompatible): Bignum;

        /** Return a new Bignum of the value integer divided by 2^bits. Equivalent of the >> operator. */
        export function shiftRight(n: BignumCompatible, bits: BignumCompatible): Bignum;

        /** Return the greatest common divisor of the current Bignum with n as a new Bignum. */
        export function gcd(left: BignumCompatible, right: Bignum): Bignum;

        /**
         * Return the Jacobi symbol (or Legendre symbol if n is prime) of the current Bignum (= a) over n.
         * Note that n must be odd and >= 3. 0 <= a < n.
         * 
         * Returns -1 or 1 as an int (NOT a Bignum). Throws an error on failure.
         */
        export function jacobi(a: BignumCompatible, n: Bignum): number;

        /** Return the number of bits used to represent the current Bignum. */
        export function bitLength(n: BignumCompatible): number;
    }
}
